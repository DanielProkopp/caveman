#|
  This file is a part of Caveman package.
  URL: http://github.com/fukamachi/caveman
  Copyright (c) 2011 Eitarow Fukamachi <e.arrows@gmail.com>

  Caveman is freely distributable under the LLGPL License.
|#

(clack.util:namespace caveman.app
  (:use :cl
        :clack
        :clack.builder
        :clack.middleware.static
        :clack.middleware.clsql)
  (:shadow :stop)
  (:import-from :cl-ppcre
                :scan-to-strings)
  (:import-from :cl-fad
                :file-exists-p)
  (:import-from :caveman.middleware.context
                :<caveman-middleware-context>)
  (:import-from :caveman.request
                :request-method
                :path-info
                :parameter)
  (:import-from :caveman.database
                :clsql-database-setup)
  (:import-from :clsql
                :connect)
  (:export :config))

(cl-annot:enable-annot-syntax)

@export
(defclass <app> (<component>)
     ((config :initarg :config :initform nil
              :accessor config)
      (routing-rules :initarg routing-rules :initform nil
                     :accessor routing-rules)
      (acceptor :initform nil :accessor acceptor))
  (:documentation "Base class for Caveman Application. All Caveman Application must inherit this class."))

(defmethod call ((this <app>) req)
  "Overriding method. This method will be called for each request."
  (let* ((method (request-method req))
         (path-info (path-info req)))
    (loop for rule in (reverse (routing-rules this))
          for (meth (re vars) fn) = (cdr rule)
          if (string= meth method)
            do (multiple-value-bind (matchp res)
                   (scan-to-strings re path-info)
                 (when matchp
                   (let ((params
                          (loop for key in vars
                                for val in (coerce res 'list)
                                append (list
                                         (intern (symbol-name key) :keyword)
                                         val))))
                     (setf (slot-value req 'clack.request::query-parameters)
                           (append
                            params
                            (slot-value req 'clack.request::query-parameters)))
                     (return (call fn (parameter req))))))
          finally (return '(404 nil nil)))))

@export
(defmethod setup ((this <app>))
  "Initialize application. This method will be called before `start', load configuration and setup database."
  (let ((config-file (merge-pathnames #p"config.lisp"
                                      (asdf:component-pathname
                                       (asdf:find-system (type-of this))))))
    (when (file-exists-p config-file)
      (load config-file)))
  (database-setup this))

@export
(defmethod start ((this <app>)
                  &key port server debug lazy)
  "Start a server for the Application."
  (setup this)
  (setf *builder-lazy-p* lazy)
  (setf (acceptor this)
        (clackup
         (builder
          (<clack-middleware-static>
           :path "/public/"
           :root (merge-pathnames (getf (config this) :static-path)
                                  (getf (config this) :application-root)))
          (<clack-middleware-clsql>
           :database-type (getf (config this) :database-type)
           :connection-spec (getf (config this) :database-connection-spec)
           :connect-args '(:pool t :encoding :utf-8))
          <caveman-middleware-context>
          this)
         :port (or port (getf (config this) :port))
         :debug debug
         :server (or server (getf (config this) :server)))))

@export
(defmethod stop ((this <app>))
  "Stop a server."
  (clack:stop (acceptor this) :server (getf (config this) :server)))

@export
(defgeneric database-setup (app)
  (:documentation "Generic function to setup database."))

@export
(defmethod database-setup ((this <app>))
  "Default method to setup database using CLSQL."
  (clsql-database-setup
   (getf (config this) :database-type)
   (getf (config this) :database-connection-spec)))

@export
(defmethod add-route ((this <app>) routing-rule)
  "Add a routing rule to the Application."
  (setf (routing-rules this)
        (delete (car routing-rule)
                (routing-rules this)
                :key #'car))
  (push routing-rule
        (routing-rules this)))

(doc:start)

@doc:NAME "
Caveman.App - Caveman Application Class.
"

@doc:SYNOPSIS "
    ;; Usually you shouldn't write this code.
    ;; These code will be generated by `caveman.skeleton:generate'.
    (defclass <myapp> (<app>) ())
    (defvar *app* (make-instance '<myapp>
                     :config '(:application-name \"My App\"
                               :application-root #p\"~/public/\"
                               :server :hunchentoot
                               :port 8080)))
    (start *app*)
"

@doc:DESCRIPTION "
Caveman.App provide a base class `<app>' for Caveman Application.

Usually you don't have to cave about this package because `caveman.skeleton:generate' will generate code for you.
"

@doc:AUTHOR "
* Eitarow Fukamachi (e.arrows@gmail.com)
"

@doc:SEE "
* Clack.Component
"
